c
booking
c
n
c
n
c
booking
c
booking
c
@booking
c
booking
c
@booking
c
params
n
booking
params
c
params
c
params
@booking
c
@booking
c
@booking
c
next
c
next
c
next
c
{ 'error' => ["User must exist", "User can't be blank"] }
JSON.parse(response.body)
c
token.class
n
token.class
c
n
decoded_token
token
c
JWT.decode(token, Rails.application.credentials[:secret_key_base]).first
c
decoded_token['user_id']
decoded_token['user_id]
decoded_token
c
JWT.decode(token, Rails.application.credentials[:secret_key_base]).first
n
token
Decoded Token: #{token}
c
@current_user.id
self.id
user.id
params
@current_user
current_user
continue
request.headers
request
c
it { should validate_uniqueness_of(:email).case_insensitive}
user
continue
user
role
user.role
continue
next
user.admin?
user.role
next
admin_role
c
booking_params
c
params
c
booking_params
params
continue
update_params
continue
@user
@user.update(update_params)
@user
next
continue
user.customer?
continue
user.admin?
@user.errors
@user.update(update_params)
@user.update(update_params).save
@user.update(update_params)
nex@user.update(update_params)
continue
@users.pluck!(email: params[:email])
@users.find_by!(email: params[:email])
JWT.decode(token, Rails.application.credentials[:secret_key_base]).first
params[:email]
params
continue
User.find(decoded_token['id'])
User.find(decoded_token['id])
decoded_token['id']
continue
JWT.decode(token, Rails.application.credentials[:secret_key_base]).first
next
JWT.decode(token, Rails.application.credentials[:secret_key_base]).first
header.split(' ').last
header
